# $Id: spiderDButils.py,v 1.1 2012/07/03 14:21:59 leith Exp $
#
# Utilities for connection to an external database
#
# DO NOT EDIT THIS FILE.
# site-specific database code goes in spiderLocalDB
#

"""
SPIRE - The SPIDER Reconstruction Engine
Copyright (C) 2006-2008  Health Research Inc. , Menands, NY
Email:  spider@health.ny.gov

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.
"""

import os, sys
from commands import getoutput

from Tkinter import *
from   tkFileDialog   import askopenfilename
import Pmw
import GB, GG
import spiderUtils
import spiderGUtils
from spiderUtils import *

# import the code for the external database
import spiderLocalDB

"""
This module imports spiderLocalDB, with site-specific code for the
local external database. Spire modules import this module, which
is the only module that imports/communicates with spiderLocalDB.

database creation:
db = spiderDButils.createDatabaseInstance()

Put database info into GB.P:
spiderDButils.getProjectInfo(db)
"""

def createDatabaseInstance():
    " expects GB.P.ID to have the project ID "
    return spiderLocalDB.spiderDatabase()

def getProjectInfo(db): # input arg is a spiderDatabase object
    " put data from dictionary returned by getProjectInfo into GB.P "
    if not hasattr(db, 'getProjectInfo'):
        return 0
    
    dict = db.getProjectInfo() # call to database, returns a dictionary
    if dict == 0:
        return 0
    
    for key in ('title','dataext','projdir','pixelsize','kv','Cs'):
        if dict.has_key(key):
            s = 'GB.P.%s = "%s"' % (key, str(dict[key]))
            exec(s)   # put data in GB.P
    return 1

# ------------------------------------------------------------------------
# GUI for Options/preferences 
class DatabaseWindow:

    def __init__(self,master):
        self.master = master
        self.id = GB.P.ID
        if GG.prefs.balloonHelp:
            self.balloon = GG.balloon

        self.db = createDatabaseInstance()
        self.testquery = self.db.projectquery

        # the top button frame
        f1 = Frame(master)
        b1 = Button(f1,text='Test', command=self.testConnection)
        b1.pack(side='left',padx=2,pady=2)
        if GG.prefs.balloonHelp:
            self.balloon.bind(b1,'Test for connection to external database')

        b2 = Button(f1,text='Info', command=self.showInfo)
        b2.pack(side='left',padx=2,pady=2)
        if GG.prefs.balloonHelp:
            self.balloon.bind(b2,'show information about project %s' % self.id)
            
        b3 = Button(f1,text='Send query', command=self.sendQuery)
        b3.pack(side='left',padx=2,pady=2)
        if GG.prefs.balloonHelp:
            self.balloon.bind(b3,'Send the SQL query below to the database')

        b4 = Button(f1,text='Upload', command=self.uploadwindow)
        b4.pack(side='left',padx=2,pady=2)
        if GG.prefs.balloonHelp:
            self.balloon.bind(b4,'Load project data into the database')
        f1.pack(side='top', fill='x', expand=1)

        # the SQL query text box                
        f2 = Frame(master)

        self.sqlbox = Pmw.ScrolledText(f2, labelpos='nw',
                                       label_text='SQL query',
                                       text_background='white',
                                       usehullsize=1,
                                       hull_height = 160)
        self.sqlbox.setvalue(self.testquery)

        # the output text box
        self.outputbox = Pmw.ScrolledText(f2, labelpos='nw',
                                          label_text='output',
                                          usehullsize=1,
                                          hull_height = 160)
        
        self.sqlbox.pack(side='top', fill='both', expand=1)
        self.outputbox.pack(side='bottom', fill='both', expand=1)

        f2.pack(side='top', fill='both', expand=1)

    def output(self, text):
        self.outputbox.setvalue(text)
        self.master.update_idletasks()
                
    def testConnection(self, cmd=None):
        self.output("Testing database connection...\n") 
        if self.db.isExtDatabaseAlive():
            outtxt = "SPIRE successfully connected to " + self.db.databaseName
        else:
            outtxt = "Unable to establish connection to " + self.db.databaseName
        self.output(outtxt)

    def showInfo(self):
        self.output("Sending test query to database...\n") 
        self.output(self.db.sendQuery(self.testquery))

    def sendQuery(self):
        self.output("Sending query to database...\n") 
        query = self.sqlbox.get()
        result = self.db.sendQuery(query)
        self.output(result)

    def uploadwindow(self):
        dbup = db_upload(self.db)
        dbup.output = self.output  # use this widget's output window
        
##########################################################################
# upload section : transfer data to the external database
#
# specify data to be loaded. Each item is a list:
#
# [table, column, prompt, type, default]
#
#  table : database table to insert into
#  column: column_name to insert into
#  prompt: a more user-friendly descriptive label
#  type : must be one of ("string", "text_file", "binary")
#         string is a value, such as "15.6A",
#         text_file is a text file to be inserted in its entirety,
#         binary is a binary file (image, volume) to be loaded.
#  default: default file for text & binary, leave "" for string
          
uploadfiles = spiderLocalDB.upload_data
    
class db_upload:
    " presents form to user, checks if files exist "
    def __init__(self, database):
        self.db = database
        title = "Load files into %s" % self.db.databaseName
        master = spiderGUtils.newWindow("Database upload")
        if master == 0: return
        self.master = master
        p = 4  # spacer

        for item in uploadfiles:
            default = item[4]
            if len(default) > 0 and not self.hasAnyExtension(default):
                item[4] = default + "." + GB.P.dataext

        f0 = Frame(master, background=GG.bgd01, relief=GG.frelief, borderwidth=GG.brdr)
        title = "The following files and values will be written to %s" % self.db.databaseName
        Label(f0, text=title, background=GG.bgd01).pack(side='top', padx=4, pady=4)
        f0.pack(side='top', fill='x', expand=1)
            
        f1 = Frame(master, relief=GG.frelief, borderwidth=GG.brdr)
        row = 0
        for item in uploadfiles:
            prompt = item[2]
            _type = item[3]
            default = item[4]
            var = StringVar()
            item.append(var)
            
            if _type == "string":
                dblabel = Label(f1, text=prompt+":")
                dbentry = Entry(f1, textvariable=var)
                dblabel.grid(row=row, column=0, padx=p, pady=p, sticky='e')
                dbentry.grid(row=row, column=1, padx=p, pady=p, sticky='ew')
                
            elif _type == "text_file":
                var.set(default)
                dblabel = Button(f1, text=prompt+":", anchor='e',
                                 command=Command(self.getfile, item))
                dbentry = Entry(f1, textvariable=var)
                dblabel.grid(row=row, column=0, padx=p, pady=p, sticky='ew')
                dbentry.grid(row=row, column=1, padx=p, pady=p, sticky='ew')
                spiderGUtils.seeEntry(dbentry)
            elif _type == "binary":
                var.set(default)
                dblabel = Button(f1, text=prompt+":", anchor='e',
                                 command=Command(self.getfile, item))
                dbentry = Entry(f1, textvariable=var)
                dblabel.grid(row=row, column=0, padx=p, pady=p, sticky='ew')
                dbentry.grid(row=row, column=1, padx=p, pady=p, sticky='ew')
                spiderGUtils.seeEntry(dbentry)
            else:
                spiderGUtils.displayError("%s : unrecognized type, must be ",\
                                          "string, text_file or binary" % _type)

            row = row + 1

        f1.grid_columnconfigure(1, weight=1)
                
        f1.pack(side='top', fill='x', expand=1)

        fb = Frame(master, background=GG.bgd01, relief=GG.frelief, borderwidth=GG.brdr)
        b = Button(fb, text="Upload now",
                   command=Command(self.upload, uploadfiles))
        b.pack(side='left', padx=p, pady=p)
        c = Button(fb, text="Cancel", command=master.destroy)
        c.pack(side='right', padx=p, pady=p)
        fb.pack(side='bottom', fill='x', expand=1)

    def getfile(self, item):
        filename = item[4]
        # make filetypes based on extension
        fn, ext = os.path.splitext(filename)
        file = spiderGUtils.askfilename
        ft = []
        if len(ext) != 0:
            filetypes = "*" + ext
            ft.append( (filetypes,filetypes )) # "*.dat" --> ("*.dat", "*.dat")
            ft.append( ("All files", "*") )
        f = askopenfilename(filetypes=ft)
        if type(f) != type(()):
            f = f.replace("/tmp_mnt", "")
            item[4] = f
            var = item[-1]
            var.set(f)

    def get_binary(self, v):
        print v.get()

    def upload(self, obj):
        " called when 'Upload' button pressed"
        chdir(GB.P.projdir)
        self.uploadable = []
        notfound = []
        for item in uploadfiles:
            new = []
            value = item[-1].get()   # get the StringVar's value
            value.strip()
            itype = item[3]   # text, binary or string
            if value == "":
                continue
            if itype == 'string':
                new = item[:4]
                new.append(value)
            elif itype == 'text_file' or itype == 'binary':
                if not os.path.exists(value):
                    txt = item[2] + " : " + value
                    notfound.append(txt)
                else:
                    new = item[:4]
                    new.append(value)

            if len(new) > 0: self.uploadable.append(new)

        # window to show which files were not found
        if notfound:           
            self.errw = spiderGUtils.newWindow("Files not found")
            if self.errw == 0: return

            nf = Frame(self.errw, relief=GG.frelief, borderwidth=GG.brdr)
            Label(nf, text="The following files could not be located").pack(side='top')
            for item in notfound:
                Label(nf, text=item).pack(side='top', padx=4, pady=2)
            nf.pack(side='top', fill='x', expand=1)
                
            fb = Frame(self.errw, background=GG.bgd01, relief=GG.frelief, borderwidth=GG.brdr)
            b = Button(fb, text="Upload the rest",
                       command=self.go_upload)
            b.pack(side='left', padx=4, pady=4)
            c = Button(fb, text="Cancel", command=self.errw.destroy)
            c.pack(side='right', padx=4, pady=4)
            fb.pack(side='bottom', fill='x', expand=1)
            
        elif len(self.uploadable) > 0:
            self.go_upload()
        else:
            self.master.destroy()

    def go_upload(self):
        if hasattr(self, 'errw') and self.errw.winfo_exists():
            self.errw.destroy()
        self.master.destroy()
        self.db.upload(self.uploadable, self.output)
                      
    def output(self):
        "override this too"
        pass

    def hasAnyExtension(self, filename):
        " returns 1 if file has any extension (1-4 chars) "
        fn, ext = os.path.splitext(filename)
        n = len(ext)
        if n > 0 and n < 5:
            return 1
        else:
            return 0
